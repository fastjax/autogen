/* Copyright (c) 2019 OpenJAX
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * You should have received a copy of The MIT License (MIT) along with this
 * program. If not, see <http://opensource.org/licenses/MIT/>.
 */

package org.openjax.codegen.template;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.Generated;

import org.libj.lang.Strings;

public class Templates {
  private static final String GENERATED_VALUE = "Autogenerated by OpenJAX CodeGen Template (" + Templates.class.getPackage().getImplementationVersion() + ")";
  private static final String GENERATED_DATE = LocalDate.now().toString();
  private static final String[] prefixes = {"static", "java", "javax", "org", "com"};

  private static final Comparator<String> importsComparator = new Comparator<String>() {
    @Override
    public int compare(final String o1, final String o2) {
      if (o1 == null)
        return o2 == null ? 0 : -1;

      if (o2 == null)
        return 1;

      for (final String prefix : prefixes) {
        if (o1.startsWith(prefix))
          return o2.startsWith(prefix) ? o1.compareTo(o2) : -1;

        if (o2.startsWith(prefix))
          return 1;
      }

      return o1.compareTo(o2);
    }
  };

  private static String importsToString(final List<String> imports) {
    final StringBuilder builder = new StringBuilder();
    imports.sort(importsComparator);

    final Map<String,String> shortNameToFullName = new HashMap<>();
    for (final String name : imports)
      shortNameToFullName.put(name.substring(name.lastIndexOf('.') + 1), name);

    String group = null;
    final Iterator<String> iterator = imports.iterator();
    for (int i = 0; iterator.hasNext(); ++i) {
      if (i > 0)
        builder.append('\n');

      final String imp = iterator.next();
      final int dot = imp.indexOf('.');
      if (dot != -1) {
        final String basePackage = imp.substring(0, dot);
        if (i > 0 && (group == null || !group.equals(basePackage)))
          builder.append('\n');

        group = basePackage;
      }

      builder.append("import ").append(imp).append(';');
    }

    return builder.toString();
  }

  private static boolean isBoundaryChar(final String str, final int i, final boolean isStart) {
    if (isStart ? i == 0 : str.length() == i)
      return true;

    final char ch = str.charAt(i + (isStart ? -1 : 0));
    return Character.isWhitespace(ch) || ch == '(' || ch == ')' || ch == '{' || ch == '}' || ch == '[' || ch == ']' || ch == '<' || ch == '>' || ch == ',' || ch == ';' || ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '&' || ch == '!' || ch == '%' || ch == '.' || ch == '@';
  }

  private static int matches(final String line, final int fromIndex, final String ... words) {
    for (final String word : words) {
      final int i = line.indexOf(word, fromIndex);
      if (i != -1 && isBoundaryChar(line, i, true) && isBoundaryChar(line, i + word.length(), false))
        return i;
    }

    return -1;
  }

  public static String render(String str, final Map<String,String> paramToType) {
    for (final Map.Entry<String,String> entry : paramToType.entrySet()) {
      final String value = entry.getValue() != null ? entry.getValue() : "";
      str = str.replace("<" + entry.getKey() + ">", value);
    }

    return str;
  }

  private static int getClassDeclarationStart(final String str, int fromIndex) {
    int index = -1;
    for (int i = fromIndex; i >= 0; --i) {
      final char ch = str.charAt(i);
      if (Character.isWhitespace(ch) || i == 0) {
        if (i != fromIndex - 1) {
          final String word = str.substring(i + 1, fromIndex);
          if ("public".equals(word) || "abstract".equals(word) || "final".equals(word))
            index = i + 1;
          else if (index != -1)
            break;
        }

        fromIndex = i;
      }
    }

    if (index == -1)
      throw new IllegalStateException();

    return index;
  }

  private static void filterForImports(final String line, final Set<String> shortNames, final Set<String> seen) {
    for (final String shortName : shortNames)
      if (matches(line, 0, shortName) != -1)
        seen.add(shortName);
  }

  public static String render(final File file, final Map<String,String> paramToType, Set<String> imports) throws IOException {
    if (imports == null)
      imports = new HashSet<>();

    final StringBuilder builder = new StringBuilder();
    try (final BufferedReader fin = new BufferedReader(new FileReader(file))) {
      int packageEnd = 0;
      int importStart = -1;
      int importEnd = -1;
      int classStart = -1;
      LinkedHashMap<String,String> shortNameToFullName = null;
      final Set<String> seen = new HashSet<>();
      String line;
      for (int i = 0; (line = fin.readLine()) != null; ++i) {
        if (i > 0)
          builder.append('\n');

        line = render(line, paramToType);
        builder.append(line);

        if (classStart == -1) {
          int classIndex = matches(line, 0, "class", "interface", "@interface");
          if (classIndex == -1)
            continue;

          line = line.trim();
          if (line.startsWith("*") || line.startsWith("//"))
            continue;

          classIndex += builder.length() - line.length();
          final String header = builder.toString();
          classStart = getClassDeclarationStart(header, classIndex);
          final int packageIndex = matches(header, 0, "package");
          if (packageIndex != -1) {
            packageEnd = header.indexOf(';', packageIndex + 8) + 1;
          }

          for (int start, end = 0; (start = matches(header, end, "import")) != -1;) {
            if (importStart == -1)
              importStart = start;

            end = header.indexOf(';', start + 7);
            imports.add(header.substring(start + 7, end++).trim());
            importEnd = end;
          }

          final ArrayList<String> list = new ArrayList<>(imports);
          list.sort(importsComparator);

          shortNameToFullName = new LinkedHashMap<>();
          for (final String name : list)
            shortNameToFullName.put(name.substring(name.lastIndexOf('.') + 1), name);
        }

        filterForImports(line, shortNameToFullName.keySet(), seen);
      }

      final int serialVersionUIDIndex = builder.indexOf("<serialVersionUID>");
      if (serialVersionUIDIndex != -1) {
        final long serialVersionUID = Strings.hash(builder.substring(classStart));
        builder.replace(serialVersionUIDIndex, serialVersionUIDIndex + 18, serialVersionUID + "L");
      }

      shortNameToFullName.put(Generated.class.getSimpleName(), Generated.class.getName());
      seen.add(Generated.class.getSimpleName());
      builder.insert(classStart, "@" + Generated.class.getSimpleName() + "(value=\"" + GENERATED_VALUE + "\", date=\"" + GENERATED_DATE + "\")\n");

      shortNameToFullName.keySet().retainAll(seen);
      final String importString = importsToString(new ArrayList<>(shortNameToFullName.values()));
      if (importStart != -1) {
        builder.replace(importStart, importEnd, importString);
      }
      else {
        if (packageEnd > 0) {
          builder.insert(packageEnd, "\n\n");
          packageEnd += 2;
        }

        builder.insert(packageEnd, importString);
      }
    }

    return builder.toString();
  }
}